// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: client.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Centrifugal_Centrifuge_Protocol_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var message: String = String()

  var temporary: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_EmulationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var node: String = String()

  var session: String = String()

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command sent from a client to a server.
/// ProtocolVersion1 uses id, method and params fields.
/// ProtocolVersion2 uses id and one of the possible request messages.
struct Centrifugal_Centrifuge_Protocol_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of command to let client match replies to commands.
  var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Method is used in ProtocolVersion1 only.
  var method: Centrifugal_Centrifuge_Protocol_Command.MethodType {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  /// Params is used in ProtocolVersion1 only.
  var params: Data {
    get {return _storage._params}
    set {_uniqueStorage()._params = newValue}
  }

  /// ProtocolVersion2 client can send one of the following requests. Server will
  /// only take the first non-null request out of these and may return an error if
  /// client passed more than one request. We are not using oneof here due to JSON
  /// interoperability concerns.
  var connect: Centrifugal_Centrifuge_Protocol_ConnectRequest {
    get {return _storage._connect ?? Centrifugal_Centrifuge_Protocol_ConnectRequest()}
    set {_uniqueStorage()._connect = newValue}
  }
  /// Returns true if `connect` has been explicitly set.
  var hasConnect: Bool {return _storage._connect != nil}
  /// Clears the value of `connect`. Subsequent reads from it will return its default value.
  mutating func clearConnect() {_uniqueStorage()._connect = nil}

  var subscribe: Centrifugal_Centrifuge_Protocol_SubscribeRequest {
    get {return _storage._subscribe ?? Centrifugal_Centrifuge_Protocol_SubscribeRequest()}
    set {_uniqueStorage()._subscribe = newValue}
  }
  /// Returns true if `subscribe` has been explicitly set.
  var hasSubscribe: Bool {return _storage._subscribe != nil}
  /// Clears the value of `subscribe`. Subsequent reads from it will return its default value.
  mutating func clearSubscribe() {_uniqueStorage()._subscribe = nil}

  var unsubscribe: Centrifugal_Centrifuge_Protocol_UnsubscribeRequest {
    get {return _storage._unsubscribe ?? Centrifugal_Centrifuge_Protocol_UnsubscribeRequest()}
    set {_uniqueStorage()._unsubscribe = newValue}
  }
  /// Returns true if `unsubscribe` has been explicitly set.
  var hasUnsubscribe: Bool {return _storage._unsubscribe != nil}
  /// Clears the value of `unsubscribe`. Subsequent reads from it will return its default value.
  mutating func clearUnsubscribe() {_uniqueStorage()._unsubscribe = nil}

  var publish: Centrifugal_Centrifuge_Protocol_PublishRequest {
    get {return _storage._publish ?? Centrifugal_Centrifuge_Protocol_PublishRequest()}
    set {_uniqueStorage()._publish = newValue}
  }
  /// Returns true if `publish` has been explicitly set.
  var hasPublish: Bool {return _storage._publish != nil}
  /// Clears the value of `publish`. Subsequent reads from it will return its default value.
  mutating func clearPublish() {_uniqueStorage()._publish = nil}

  var presence: Centrifugal_Centrifuge_Protocol_PresenceRequest {
    get {return _storage._presence ?? Centrifugal_Centrifuge_Protocol_PresenceRequest()}
    set {_uniqueStorage()._presence = newValue}
  }
  /// Returns true if `presence` has been explicitly set.
  var hasPresence: Bool {return _storage._presence != nil}
  /// Clears the value of `presence`. Subsequent reads from it will return its default value.
  mutating func clearPresence() {_uniqueStorage()._presence = nil}

  var presenceStats: Centrifugal_Centrifuge_Protocol_PresenceStatsRequest {
    get {return _storage._presenceStats ?? Centrifugal_Centrifuge_Protocol_PresenceStatsRequest()}
    set {_uniqueStorage()._presenceStats = newValue}
  }
  /// Returns true if `presenceStats` has been explicitly set.
  var hasPresenceStats: Bool {return _storage._presenceStats != nil}
  /// Clears the value of `presenceStats`. Subsequent reads from it will return its default value.
  mutating func clearPresenceStats() {_uniqueStorage()._presenceStats = nil}

  var history: Centrifugal_Centrifuge_Protocol_HistoryRequest {
    get {return _storage._history ?? Centrifugal_Centrifuge_Protocol_HistoryRequest()}
    set {_uniqueStorage()._history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  var hasHistory: Bool {return _storage._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  mutating func clearHistory() {_uniqueStorage()._history = nil}

  var ping: Centrifugal_Centrifuge_Protocol_PingRequest {
    get {return _storage._ping ?? Centrifugal_Centrifuge_Protocol_PingRequest()}
    set {_uniqueStorage()._ping = newValue}
  }
  /// Returns true if `ping` has been explicitly set.
  var hasPing: Bool {return _storage._ping != nil}
  /// Clears the value of `ping`. Subsequent reads from it will return its default value.
  mutating func clearPing() {_uniqueStorage()._ping = nil}

  var send: Centrifugal_Centrifuge_Protocol_SendRequest {
    get {return _storage._send ?? Centrifugal_Centrifuge_Protocol_SendRequest()}
    set {_uniqueStorage()._send = newValue}
  }
  /// Returns true if `send` has been explicitly set.
  var hasSend: Bool {return _storage._send != nil}
  /// Clears the value of `send`. Subsequent reads from it will return its default value.
  mutating func clearSend() {_uniqueStorage()._send = nil}

  var rpc: Centrifugal_Centrifuge_Protocol_RPCRequest {
    get {return _storage._rpc ?? Centrifugal_Centrifuge_Protocol_RPCRequest()}
    set {_uniqueStorage()._rpc = newValue}
  }
  /// Returns true if `rpc` has been explicitly set.
  var hasRpc: Bool {return _storage._rpc != nil}
  /// Clears the value of `rpc`. Subsequent reads from it will return its default value.
  mutating func clearRpc() {_uniqueStorage()._rpc = nil}

  var refresh: Centrifugal_Centrifuge_Protocol_RefreshRequest {
    get {return _storage._refresh ?? Centrifugal_Centrifuge_Protocol_RefreshRequest()}
    set {_uniqueStorage()._refresh = newValue}
  }
  /// Returns true if `refresh` has been explicitly set.
  var hasRefresh: Bool {return _storage._refresh != nil}
  /// Clears the value of `refresh`. Subsequent reads from it will return its default value.
  mutating func clearRefresh() {_uniqueStorage()._refresh = nil}

  var subRefresh: Centrifugal_Centrifuge_Protocol_SubRefreshRequest {
    get {return _storage._subRefresh ?? Centrifugal_Centrifuge_Protocol_SubRefreshRequest()}
    set {_uniqueStorage()._subRefresh = newValue}
  }
  /// Returns true if `subRefresh` has been explicitly set.
  var hasSubRefresh: Bool {return _storage._subRefresh != nil}
  /// Clears the value of `subRefresh`. Subsequent reads from it will return its default value.
  mutating func clearSubRefresh() {_uniqueStorage()._subRefresh = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum MethodType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case connect // = 0
    case subscribe // = 1
    case unsubscribe // = 2
    case publish // = 3
    case presence // = 4
    case presenceStats // = 5
    case history // = 6
    case ping // = 7
    case send // = 8
    case rpc // = 9
    case refresh // = 10
    case subRefresh // = 11
    case UNRECOGNIZED(Int)

    init() {
      self = .connect
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .connect
      case 1: self = .subscribe
      case 2: self = .unsubscribe
      case 3: self = .publish
      case 4: self = .presence
      case 5: self = .presenceStats
      case 6: self = .history
      case 7: self = .ping
      case 8: self = .send
      case 9: self = .rpc
      case 10: self = .refresh
      case 11: self = .subRefresh
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .connect: return 0
      case .subscribe: return 1
      case .unsubscribe: return 2
      case .publish: return 3
      case .presence: return 4
      case .presenceStats: return 5
      case .history: return 6
      case .ping: return 7
      case .send: return 8
      case .rpc: return 9
      case .refresh: return 10
      case .subRefresh: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Centrifugal_Centrifuge_Protocol_Command.MethodType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Centrifugal_Centrifuge_Protocol_Command.MethodType] = [
    .connect,
    .subscribe,
    .unsubscribe,
    .publish,
    .presence,
    .presenceStats,
    .history,
    .ping,
    .send,
    .rpc,
    .refresh,
    .subRefresh,
  ]
}

#endif  // swift(>=4.2)

/// Reply sent from a server to a client.
/// ProtocolVersion1 uses id, error and result fields.
/// ProtocolVersion2 uses id and one of the possible concrete result messages.
struct Centrifugal_Centrifuge_Protocol_Reply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id will only be set to a value > 0 for replies to commands. For pushes
  /// it will have zero value.
  var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Error can only be set in replies to commands. For pushes it will have zero value.
  var error: Centrifugal_Centrifuge_Protocol_Error {
    get {return _storage._error ?? Centrifugal_Centrifuge_Protocol_Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  /// Result is used in ProtocolVersion1 only.
  var result: Data {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  /// ProtocolVersion2 server can send one of the following fields. We are not using
  /// oneof here due to JSON interoperability concerns.
  var push: Centrifugal_Centrifuge_Protocol_Push {
    get {return _storage._push ?? Centrifugal_Centrifuge_Protocol_Push()}
    set {_uniqueStorage()._push = newValue}
  }
  /// Returns true if `push` has been explicitly set.
  var hasPush: Bool {return _storage._push != nil}
  /// Clears the value of `push`. Subsequent reads from it will return its default value.
  mutating func clearPush() {_uniqueStorage()._push = nil}

  var connect: Centrifugal_Centrifuge_Protocol_ConnectResult {
    get {return _storage._connect ?? Centrifugal_Centrifuge_Protocol_ConnectResult()}
    set {_uniqueStorage()._connect = newValue}
  }
  /// Returns true if `connect` has been explicitly set.
  var hasConnect: Bool {return _storage._connect != nil}
  /// Clears the value of `connect`. Subsequent reads from it will return its default value.
  mutating func clearConnect() {_uniqueStorage()._connect = nil}

  var subscribe: Centrifugal_Centrifuge_Protocol_SubscribeResult {
    get {return _storage._subscribe ?? Centrifugal_Centrifuge_Protocol_SubscribeResult()}
    set {_uniqueStorage()._subscribe = newValue}
  }
  /// Returns true if `subscribe` has been explicitly set.
  var hasSubscribe: Bool {return _storage._subscribe != nil}
  /// Clears the value of `subscribe`. Subsequent reads from it will return its default value.
  mutating func clearSubscribe() {_uniqueStorage()._subscribe = nil}

  var unsubscribe: Centrifugal_Centrifuge_Protocol_UnsubscribeResult {
    get {return _storage._unsubscribe ?? Centrifugal_Centrifuge_Protocol_UnsubscribeResult()}
    set {_uniqueStorage()._unsubscribe = newValue}
  }
  /// Returns true if `unsubscribe` has been explicitly set.
  var hasUnsubscribe: Bool {return _storage._unsubscribe != nil}
  /// Clears the value of `unsubscribe`. Subsequent reads from it will return its default value.
  mutating func clearUnsubscribe() {_uniqueStorage()._unsubscribe = nil}

  var publish: Centrifugal_Centrifuge_Protocol_PublishResult {
    get {return _storage._publish ?? Centrifugal_Centrifuge_Protocol_PublishResult()}
    set {_uniqueStorage()._publish = newValue}
  }
  /// Returns true if `publish` has been explicitly set.
  var hasPublish: Bool {return _storage._publish != nil}
  /// Clears the value of `publish`. Subsequent reads from it will return its default value.
  mutating func clearPublish() {_uniqueStorage()._publish = nil}

  var presence: Centrifugal_Centrifuge_Protocol_PresenceResult {
    get {return _storage._presence ?? Centrifugal_Centrifuge_Protocol_PresenceResult()}
    set {_uniqueStorage()._presence = newValue}
  }
  /// Returns true if `presence` has been explicitly set.
  var hasPresence: Bool {return _storage._presence != nil}
  /// Clears the value of `presence`. Subsequent reads from it will return its default value.
  mutating func clearPresence() {_uniqueStorage()._presence = nil}

  var presenceStats: Centrifugal_Centrifuge_Protocol_PresenceStatsResult {
    get {return _storage._presenceStats ?? Centrifugal_Centrifuge_Protocol_PresenceStatsResult()}
    set {_uniqueStorage()._presenceStats = newValue}
  }
  /// Returns true if `presenceStats` has been explicitly set.
  var hasPresenceStats: Bool {return _storage._presenceStats != nil}
  /// Clears the value of `presenceStats`. Subsequent reads from it will return its default value.
  mutating func clearPresenceStats() {_uniqueStorage()._presenceStats = nil}

  var history: Centrifugal_Centrifuge_Protocol_HistoryResult {
    get {return _storage._history ?? Centrifugal_Centrifuge_Protocol_HistoryResult()}
    set {_uniqueStorage()._history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  var hasHistory: Bool {return _storage._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  mutating func clearHistory() {_uniqueStorage()._history = nil}

  var ping: Centrifugal_Centrifuge_Protocol_PingResult {
    get {return _storage._ping ?? Centrifugal_Centrifuge_Protocol_PingResult()}
    set {_uniqueStorage()._ping = newValue}
  }
  /// Returns true if `ping` has been explicitly set.
  var hasPing: Bool {return _storage._ping != nil}
  /// Clears the value of `ping`. Subsequent reads from it will return its default value.
  mutating func clearPing() {_uniqueStorage()._ping = nil}

  var rpc: Centrifugal_Centrifuge_Protocol_RPCResult {
    get {return _storage._rpc ?? Centrifugal_Centrifuge_Protocol_RPCResult()}
    set {_uniqueStorage()._rpc = newValue}
  }
  /// Returns true if `rpc` has been explicitly set.
  var hasRpc: Bool {return _storage._rpc != nil}
  /// Clears the value of `rpc`. Subsequent reads from it will return its default value.
  mutating func clearRpc() {_uniqueStorage()._rpc = nil}

  var refresh: Centrifugal_Centrifuge_Protocol_RefreshResult {
    get {return _storage._refresh ?? Centrifugal_Centrifuge_Protocol_RefreshResult()}
    set {_uniqueStorage()._refresh = newValue}
  }
  /// Returns true if `refresh` has been explicitly set.
  var hasRefresh: Bool {return _storage._refresh != nil}
  /// Clears the value of `refresh`. Subsequent reads from it will return its default value.
  mutating func clearRefresh() {_uniqueStorage()._refresh = nil}

  var subRefresh: Centrifugal_Centrifuge_Protocol_SubRefreshResult {
    get {return _storage._subRefresh ?? Centrifugal_Centrifuge_Protocol_SubRefreshResult()}
    set {_uniqueStorage()._subRefresh = newValue}
  }
  /// Returns true if `subRefresh` has been explicitly set.
  var hasSubRefresh: Bool {return _storage._subRefresh != nil}
  /// Clears the value of `subRefresh`. Subsequent reads from it will return its default value.
  mutating func clearSubRefresh() {_uniqueStorage()._subRefresh = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Push can be sent to a client as part of Reply in case of bidirectional transport or
/// without additional wrapping in case of unidirectional transports.
/// ProtocolVersion1 uses type, channel and data fields.
/// ProtocolVersion2 uses channel and one of the possible concrete push messages.
struct Centrifugal_Centrifuge_Protocol_Push {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is used in ProtocolVersion1 only.
  var type: Centrifugal_Centrifuge_Protocol_Push.PushType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var channel: String {
    get {return _storage._channel}
    set {_uniqueStorage()._channel = newValue}
  }

  /// Data is used in ProtocolVersion1 only.
  var data: Data {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  /// ProtocolVersion2 server can push one of the following fields to the client. We are
  /// not using oneof here due to JSON interoperability concerns.
  var pub: Centrifugal_Centrifuge_Protocol_Publication {
    get {return _storage._pub ?? Centrifugal_Centrifuge_Protocol_Publication()}
    set {_uniqueStorage()._pub = newValue}
  }
  /// Returns true if `pub` has been explicitly set.
  var hasPub: Bool {return _storage._pub != nil}
  /// Clears the value of `pub`. Subsequent reads from it will return its default value.
  mutating func clearPub() {_uniqueStorage()._pub = nil}

  var join: Centrifugal_Centrifuge_Protocol_Join {
    get {return _storage._join ?? Centrifugal_Centrifuge_Protocol_Join()}
    set {_uniqueStorage()._join = newValue}
  }
  /// Returns true if `join` has been explicitly set.
  var hasJoin: Bool {return _storage._join != nil}
  /// Clears the value of `join`. Subsequent reads from it will return its default value.
  mutating func clearJoin() {_uniqueStorage()._join = nil}

  var leave: Centrifugal_Centrifuge_Protocol_Leave {
    get {return _storage._leave ?? Centrifugal_Centrifuge_Protocol_Leave()}
    set {_uniqueStorage()._leave = newValue}
  }
  /// Returns true if `leave` has been explicitly set.
  var hasLeave: Bool {return _storage._leave != nil}
  /// Clears the value of `leave`. Subsequent reads from it will return its default value.
  mutating func clearLeave() {_uniqueStorage()._leave = nil}

  var unsubscribe: Centrifugal_Centrifuge_Protocol_Unsubscribe {
    get {return _storage._unsubscribe ?? Centrifugal_Centrifuge_Protocol_Unsubscribe()}
    set {_uniqueStorage()._unsubscribe = newValue}
  }
  /// Returns true if `unsubscribe` has been explicitly set.
  var hasUnsubscribe: Bool {return _storage._unsubscribe != nil}
  /// Clears the value of `unsubscribe`. Subsequent reads from it will return its default value.
  mutating func clearUnsubscribe() {_uniqueStorage()._unsubscribe = nil}

  var message: Centrifugal_Centrifuge_Protocol_Message {
    get {return _storage._message ?? Centrifugal_Centrifuge_Protocol_Message()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var subscribe: Centrifugal_Centrifuge_Protocol_Subscribe {
    get {return _storage._subscribe ?? Centrifugal_Centrifuge_Protocol_Subscribe()}
    set {_uniqueStorage()._subscribe = newValue}
  }
  /// Returns true if `subscribe` has been explicitly set.
  var hasSubscribe: Bool {return _storage._subscribe != nil}
  /// Clears the value of `subscribe`. Subsequent reads from it will return its default value.
  mutating func clearSubscribe() {_uniqueStorage()._subscribe = nil}

  var connect: Centrifugal_Centrifuge_Protocol_Connect {
    get {return _storage._connect ?? Centrifugal_Centrifuge_Protocol_Connect()}
    set {_uniqueStorage()._connect = newValue}
  }
  /// Returns true if `connect` has been explicitly set.
  var hasConnect: Bool {return _storage._connect != nil}
  /// Clears the value of `connect`. Subsequent reads from it will return its default value.
  mutating func clearConnect() {_uniqueStorage()._connect = nil}

  var disconnect: Centrifugal_Centrifuge_Protocol_Disconnect {
    get {return _storage._disconnect ?? Centrifugal_Centrifuge_Protocol_Disconnect()}
    set {_uniqueStorage()._disconnect = newValue}
  }
  /// Returns true if `disconnect` has been explicitly set.
  var hasDisconnect: Bool {return _storage._disconnect != nil}
  /// Clears the value of `disconnect`. Subsequent reads from it will return its default value.
  mutating func clearDisconnect() {_uniqueStorage()._disconnect = nil}

  var refresh: Centrifugal_Centrifuge_Protocol_Refresh {
    get {return _storage._refresh ?? Centrifugal_Centrifuge_Protocol_Refresh()}
    set {_uniqueStorage()._refresh = newValue}
  }
  /// Returns true if `refresh` has been explicitly set.
  var hasRefresh: Bool {return _storage._refresh != nil}
  /// Clears the value of `refresh`. Subsequent reads from it will return its default value.
  mutating func clearRefresh() {_uniqueStorage()._refresh = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PushType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case publication // = 0
    case join // = 1
    case leave // = 2
    case unsubscribe // = 3
    case message // = 4
    case subscribe // = 5
    case connect // = 6
    case disconnect // = 7
    case refresh // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .publication
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .publication
      case 1: self = .join
      case 2: self = .leave
      case 3: self = .unsubscribe
      case 4: self = .message
      case 5: self = .subscribe
      case 6: self = .connect
      case 7: self = .disconnect
      case 8: self = .refresh
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .publication: return 0
      case .join: return 1
      case .leave: return 2
      case .unsubscribe: return 3
      case .message: return 4
      case .subscribe: return 5
      case .connect: return 6
      case .disconnect: return 7
      case .refresh: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Centrifugal_Centrifuge_Protocol_Push.PushType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Centrifugal_Centrifuge_Protocol_Push.PushType] = [
    .publication,
    .join,
    .leave,
    .unsubscribe,
    .message,
    .subscribe,
    .connect,
    .disconnect,
    .refresh,
  ]
}

#endif  // swift(>=4.2)

struct Centrifugal_Centrifuge_Protocol_ClientInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var user: String = String()

  var client: String = String()

  var connInfo: Data = Data()

  var chanInfo: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_Publication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 1-3 skipped here for backwards compatibility.
  var data: Data = Data()

  var info: Centrifugal_Centrifuge_Protocol_ClientInfo {
    get {return _info ?? Centrifugal_Centrifuge_Protocol_ClientInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var offset: UInt64 = 0

  var tags: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Centrifugal_Centrifuge_Protocol_ClientInfo? = nil
}

struct Centrifugal_Centrifuge_Protocol_Join {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: Centrifugal_Centrifuge_Protocol_ClientInfo {
    get {return _info ?? Centrifugal_Centrifuge_Protocol_ClientInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Centrifugal_Centrifuge_Protocol_ClientInfo? = nil
}

struct Centrifugal_Centrifuge_Protocol_Leave {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: Centrifugal_Centrifuge_Protocol_ClientInfo {
    get {return _info ?? Centrifugal_Centrifuge_Protocol_ClientInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Centrifugal_Centrifuge_Protocol_ClientInfo? = nil
}

struct Centrifugal_Centrifuge_Protocol_Unsubscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Centrifugal_Centrifuge_Protocol_Unsubscribe.TypeEnum = .permanent

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Field 1 removed (bool resubscribe).
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case permanent // = 0
    case insufficient // = 1
    case unrecoverable // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .permanent
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .permanent
      case 1: self = .insufficient
      case 2: self = .unrecoverable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .permanent: return 0
      case .insufficient: return 1
      case .unrecoverable: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Centrifugal_Centrifuge_Protocol_Unsubscribe.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Centrifugal_Centrifuge_Protocol_Unsubscribe.TypeEnum] = [
    .permanent,
    .insufficient,
    .unrecoverable,
  ]
}

#endif  // swift(>=4.2)

struct Centrifugal_Centrifuge_Protocol_Subscribe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recoverable: Bool = false

  /// 2-3 skipped here for backwards compatibility.
  var epoch: String = String()

  var offset: UInt64 = 0

  var positioned: Bool = false

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_Connect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var client: String = String()

  var version: String = String()

  var data: Data = Data()

  var subs: Dictionary<String,Centrifugal_Centrifuge_Protocol_SubscribeResult> = [:]

  var expires: Bool = false

  var ttl: UInt32 = 0

  var ping: UInt32 = 0

  var pong: Bool = false

  var session: String = String()

  var node: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_Disconnect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var reason: String = String()

  var reconnect: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_Refresh {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var expires: Bool = false

  var ttl: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_ConnectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var data: Data = Data()

  var subs: Dictionary<String,Centrifugal_Centrifuge_Protocol_SubscribeRequest> = [:]

  var name: String = String()

  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_ConnectResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var client: String = String()

  var version: String = String()

  var expires: Bool = false

  var ttl: UInt32 = 0

  var data: Data = Data()

  var subs: Dictionary<String,Centrifugal_Centrifuge_Protocol_SubscribeResult> = [:]

  var ping: UInt32 = 0

  var pong: Bool = false

  var session: String = String()

  var node: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_RefreshRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_RefreshResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var client: String = String()

  var version: String = String()

  var expires: Bool = false

  var ttl: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_SubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: String = String()

  var token: String = String()

  var recover: Bool = false

  /// 4-5 skipped here for backwards compatibility.
  var epoch: String = String()

  var offset: UInt64 = 0

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_SubscribeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var expires: Bool = false

  var ttl: UInt32 = 0

  var recoverable: Bool = false

  /// 4-5 skipped here for backwards compatibility.
  var epoch: String = String()

  var publications: [Centrifugal_Centrifuge_Protocol_Publication] = []

  var recovered: Bool = false

  var offset: UInt64 = 0

  var positioned: Bool = false

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_SubRefreshRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: String = String()

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_SubRefreshResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var expires: Bool = false

  var ttl: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_UnsubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_UnsubscribeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_PublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: String = String()

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_PublishResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_PresenceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_PresenceResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var presence: Dictionary<String,Centrifugal_Centrifuge_Protocol_ClientInfo> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_PresenceStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_PresenceStatsResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numClients: UInt32 = 0

  var numUsers: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_StreamPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offset: UInt64 = 0

  var epoch: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_HistoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: String = String()

  /// 2-6 skipped here for backwards compatibility.
  var limit: Int32 = 0

  var since: Centrifugal_Centrifuge_Protocol_StreamPosition {
    get {return _since ?? Centrifugal_Centrifuge_Protocol_StreamPosition()}
    set {_since = newValue}
  }
  /// Returns true if `since` has been explicitly set.
  var hasSince: Bool {return self._since != nil}
  /// Clears the value of `since`. Subsequent reads from it will return its default value.
  mutating func clearSince() {self._since = nil}

  var reverse: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _since: Centrifugal_Centrifuge_Protocol_StreamPosition? = nil
}

struct Centrifugal_Centrifuge_Protocol_HistoryResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publications: [Centrifugal_Centrifuge_Protocol_Publication] = []

  var epoch: String = String()

  var offset: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_PingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_PingResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_RPCRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var method: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_RPCResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Centrifugal_Centrifuge_Protocol_SendRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "centrifugal.centrifuge.protocol"

extension Centrifugal_Centrifuge_Protocol_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "temporary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.temporary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.temporary != false {
      try visitor.visitSingularBoolField(value: self.temporary, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Error, rhs: Centrifugal_Centrifuge_Protocol_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.temporary != rhs.temporary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_EmulationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmulationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .same(proto: "session"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.node) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.node.isEmpty {
      try visitor.visitSingularStringField(value: self.node, fieldNumber: 1)
    }
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_EmulationRequest, rhs: Centrifugal_Centrifuge_Protocol_EmulationRequest) -> Bool {
    if lhs.node != rhs.node {return false}
    if lhs.session != rhs.session {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "method"),
    3: .same(proto: "params"),
    4: .same(proto: "connect"),
    5: .same(proto: "subscribe"),
    6: .same(proto: "unsubscribe"),
    7: .same(proto: "publish"),
    8: .same(proto: "presence"),
    9: .standard(proto: "presence_stats"),
    10: .same(proto: "history"),
    11: .same(proto: "ping"),
    12: .same(proto: "send"),
    13: .same(proto: "rpc"),
    14: .same(proto: "refresh"),
    15: .standard(proto: "sub_refresh"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt32 = 0
    var _method: Centrifugal_Centrifuge_Protocol_Command.MethodType = .connect
    var _params: Data = Data()
    var _connect: Centrifugal_Centrifuge_Protocol_ConnectRequest? = nil
    var _subscribe: Centrifugal_Centrifuge_Protocol_SubscribeRequest? = nil
    var _unsubscribe: Centrifugal_Centrifuge_Protocol_UnsubscribeRequest? = nil
    var _publish: Centrifugal_Centrifuge_Protocol_PublishRequest? = nil
    var _presence: Centrifugal_Centrifuge_Protocol_PresenceRequest? = nil
    var _presenceStats: Centrifugal_Centrifuge_Protocol_PresenceStatsRequest? = nil
    var _history: Centrifugal_Centrifuge_Protocol_HistoryRequest? = nil
    var _ping: Centrifugal_Centrifuge_Protocol_PingRequest? = nil
    var _send: Centrifugal_Centrifuge_Protocol_SendRequest? = nil
    var _rpc: Centrifugal_Centrifuge_Protocol_RPCRequest? = nil
    var _refresh: Centrifugal_Centrifuge_Protocol_RefreshRequest? = nil
    var _subRefresh: Centrifugal_Centrifuge_Protocol_SubRefreshRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _method = source._method
      _params = source._params
      _connect = source._connect
      _subscribe = source._subscribe
      _unsubscribe = source._unsubscribe
      _publish = source._publish
      _presence = source._presence
      _presenceStats = source._presenceStats
      _history = source._history
      _ping = source._ping
      _send = source._send
      _rpc = source._rpc
      _refresh = source._refresh
      _subRefresh = source._subRefresh
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._method) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._params) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connect) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._subscribe) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._unsubscribe) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._publish) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._presence) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._presenceStats) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._history) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._ping) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._send) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._rpc) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._refresh) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._subRefresh) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._method != .connect {
        try visitor.visitSingularEnumField(value: _storage._method, fieldNumber: 2)
      }
      if !_storage._params.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._params, fieldNumber: 3)
      }
      try { if let v = _storage._connect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._subscribe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._unsubscribe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._publish {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._presence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._presenceStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._history {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._ping {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._send {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._rpc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._refresh {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._subRefresh {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Command, rhs: Centrifugal_Centrifuge_Protocol_Command) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._connect != rhs_storage._connect {return false}
        if _storage._subscribe != rhs_storage._subscribe {return false}
        if _storage._unsubscribe != rhs_storage._unsubscribe {return false}
        if _storage._publish != rhs_storage._publish {return false}
        if _storage._presence != rhs_storage._presence {return false}
        if _storage._presenceStats != rhs_storage._presenceStats {return false}
        if _storage._history != rhs_storage._history {return false}
        if _storage._ping != rhs_storage._ping {return false}
        if _storage._send != rhs_storage._send {return false}
        if _storage._rpc != rhs_storage._rpc {return false}
        if _storage._refresh != rhs_storage._refresh {return false}
        if _storage._subRefresh != rhs_storage._subRefresh {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Command.MethodType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECT"),
    1: .same(proto: "SUBSCRIBE"),
    2: .same(proto: "UNSUBSCRIBE"),
    3: .same(proto: "PUBLISH"),
    4: .same(proto: "PRESENCE"),
    5: .same(proto: "PRESENCE_STATS"),
    6: .same(proto: "HISTORY"),
    7: .same(proto: "PING"),
    8: .same(proto: "SEND"),
    9: .same(proto: "RPC"),
    10: .same(proto: "REFRESH"),
    11: .same(proto: "SUB_REFRESH"),
  ]
}

extension Centrifugal_Centrifuge_Protocol_Reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .same(proto: "result"),
    4: .same(proto: "push"),
    5: .same(proto: "connect"),
    6: .same(proto: "subscribe"),
    7: .same(proto: "unsubscribe"),
    8: .same(proto: "publish"),
    9: .same(proto: "presence"),
    10: .standard(proto: "presence_stats"),
    11: .same(proto: "history"),
    12: .same(proto: "ping"),
    13: .same(proto: "rpc"),
    14: .same(proto: "refresh"),
    15: .standard(proto: "sub_refresh"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt32 = 0
    var _error: Centrifugal_Centrifuge_Protocol_Error? = nil
    var _result: Data = Data()
    var _push: Centrifugal_Centrifuge_Protocol_Push? = nil
    var _connect: Centrifugal_Centrifuge_Protocol_ConnectResult? = nil
    var _subscribe: Centrifugal_Centrifuge_Protocol_SubscribeResult? = nil
    var _unsubscribe: Centrifugal_Centrifuge_Protocol_UnsubscribeResult? = nil
    var _publish: Centrifugal_Centrifuge_Protocol_PublishResult? = nil
    var _presence: Centrifugal_Centrifuge_Protocol_PresenceResult? = nil
    var _presenceStats: Centrifugal_Centrifuge_Protocol_PresenceStatsResult? = nil
    var _history: Centrifugal_Centrifuge_Protocol_HistoryResult? = nil
    var _ping: Centrifugal_Centrifuge_Protocol_PingResult? = nil
    var _rpc: Centrifugal_Centrifuge_Protocol_RPCResult? = nil
    var _refresh: Centrifugal_Centrifuge_Protocol_RefreshResult? = nil
    var _subRefresh: Centrifugal_Centrifuge_Protocol_SubRefreshResult? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _error = source._error
      _result = source._result
      _push = source._push
      _connect = source._connect
      _subscribe = source._subscribe
      _unsubscribe = source._unsubscribe
      _publish = source._publish
      _presence = source._presence
      _presenceStats = source._presenceStats
      _history = source._history
      _ping = source._ping
      _rpc = source._rpc
      _refresh = source._refresh
      _subRefresh = source._subRefresh
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._result) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._push) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connect) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._subscribe) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._unsubscribe) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._publish) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._presence) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._presenceStats) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._history) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._ping) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._rpc) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._refresh) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._subRefresh) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._result.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._result, fieldNumber: 3)
      }
      try { if let v = _storage._push {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._subscribe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._unsubscribe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._publish {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._presence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._presenceStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._history {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._ping {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._rpc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._refresh {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._subRefresh {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Reply, rhs: Centrifugal_Centrifuge_Protocol_Reply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._error != rhs_storage._error {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._push != rhs_storage._push {return false}
        if _storage._connect != rhs_storage._connect {return false}
        if _storage._subscribe != rhs_storage._subscribe {return false}
        if _storage._unsubscribe != rhs_storage._unsubscribe {return false}
        if _storage._publish != rhs_storage._publish {return false}
        if _storage._presence != rhs_storage._presence {return false}
        if _storage._presenceStats != rhs_storage._presenceStats {return false}
        if _storage._history != rhs_storage._history {return false}
        if _storage._ping != rhs_storage._ping {return false}
        if _storage._rpc != rhs_storage._rpc {return false}
        if _storage._refresh != rhs_storage._refresh {return false}
        if _storage._subRefresh != rhs_storage._subRefresh {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Push: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Push"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "channel"),
    3: .same(proto: "data"),
    4: .same(proto: "pub"),
    5: .same(proto: "join"),
    6: .same(proto: "leave"),
    7: .same(proto: "unsubscribe"),
    8: .same(proto: "message"),
    9: .same(proto: "subscribe"),
    10: .same(proto: "connect"),
    11: .same(proto: "disconnect"),
    12: .same(proto: "refresh"),
  ]

  fileprivate class _StorageClass {
    var _type: Centrifugal_Centrifuge_Protocol_Push.PushType = .publication
    var _channel: String = String()
    var _data: Data = Data()
    var _pub: Centrifugal_Centrifuge_Protocol_Publication? = nil
    var _join: Centrifugal_Centrifuge_Protocol_Join? = nil
    var _leave: Centrifugal_Centrifuge_Protocol_Leave? = nil
    var _unsubscribe: Centrifugal_Centrifuge_Protocol_Unsubscribe? = nil
    var _message: Centrifugal_Centrifuge_Protocol_Message? = nil
    var _subscribe: Centrifugal_Centrifuge_Protocol_Subscribe? = nil
    var _connect: Centrifugal_Centrifuge_Protocol_Connect? = nil
    var _disconnect: Centrifugal_Centrifuge_Protocol_Disconnect? = nil
    var _refresh: Centrifugal_Centrifuge_Protocol_Refresh? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _channel = source._channel
      _data = source._data
      _pub = source._pub
      _join = source._join
      _leave = source._leave
      _unsubscribe = source._unsubscribe
      _message = source._message
      _subscribe = source._subscribe
      _connect = source._connect
      _disconnect = source._disconnect
      _refresh = source._refresh
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._channel) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._data) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._pub) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._join) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._leave) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._unsubscribe) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._message) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._subscribe) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._connect) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._disconnect) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._refresh) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .publication {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._channel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channel, fieldNumber: 2)
      }
      if !_storage._data.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._data, fieldNumber: 3)
      }
      try { if let v = _storage._pub {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._join {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._leave {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._unsubscribe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._subscribe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._connect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._disconnect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._refresh {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Push, rhs: Centrifugal_Centrifuge_Protocol_Push) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._pub != rhs_storage._pub {return false}
        if _storage._join != rhs_storage._join {return false}
        if _storage._leave != rhs_storage._leave {return false}
        if _storage._unsubscribe != rhs_storage._unsubscribe {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._subscribe != rhs_storage._subscribe {return false}
        if _storage._connect != rhs_storage._connect {return false}
        if _storage._disconnect != rhs_storage._disconnect {return false}
        if _storage._refresh != rhs_storage._refresh {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Push.PushType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLICATION"),
    1: .same(proto: "JOIN"),
    2: .same(proto: "LEAVE"),
    3: .same(proto: "UNSUBSCRIBE"),
    4: .same(proto: "MESSAGE"),
    5: .same(proto: "SUBSCRIBE"),
    6: .same(proto: "CONNECT"),
    7: .same(proto: "DISCONNECT"),
    8: .same(proto: "REFRESH"),
  ]
}

extension Centrifugal_Centrifuge_Protocol_ClientInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "client"),
    3: .standard(proto: "conn_info"),
    4: .standard(proto: "chan_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.client) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.connInfo) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.chanInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.client.isEmpty {
      try visitor.visitSingularStringField(value: self.client, fieldNumber: 2)
    }
    if !self.connInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.connInfo, fieldNumber: 3)
    }
    if !self.chanInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.chanInfo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_ClientInfo, rhs: Centrifugal_Centrifuge_Protocol_ClientInfo) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.client != rhs.client {return false}
    if lhs.connInfo != rhs.connInfo {return false}
    if lhs.chanInfo != rhs.chanInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Publication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Publication"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "data"),
    5: .same(proto: "info"),
    6: .same(proto: "offset"),
    7: .same(proto: "tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.offset) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.offset != 0 {
      try visitor.visitSingularUInt64Field(value: self.offset, fieldNumber: 6)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Publication, rhs: Centrifugal_Centrifuge_Protocol_Publication) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs._info != rhs._info {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Join: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Join"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Join, rhs: Centrifugal_Centrifuge_Protocol_Join) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Leave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Leave"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Leave, rhs: Centrifugal_Centrifuge_Protocol_Leave) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Unsubscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unsubscribe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .permanent {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Unsubscribe, rhs: Centrifugal_Centrifuge_Protocol_Unsubscribe) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Unsubscribe.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERMANENT"),
    1: .same(proto: "INSUFFICIENT"),
    2: .same(proto: "UNRECOVERABLE"),
  ]
}

extension Centrifugal_Centrifuge_Protocol_Subscribe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Subscribe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recoverable"),
    4: .same(proto: "epoch"),
    5: .same(proto: "offset"),
    6: .same(proto: "positioned"),
    7: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.recoverable) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.epoch) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.offset) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.positioned) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.recoverable != false {
      try visitor.visitSingularBoolField(value: self.recoverable, fieldNumber: 1)
    }
    if !self.epoch.isEmpty {
      try visitor.visitSingularStringField(value: self.epoch, fieldNumber: 4)
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt64Field(value: self.offset, fieldNumber: 5)
    }
    if self.positioned != false {
      try visitor.visitSingularBoolField(value: self.positioned, fieldNumber: 6)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Subscribe, rhs: Centrifugal_Centrifuge_Protocol_Subscribe) -> Bool {
    if lhs.recoverable != rhs.recoverable {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.positioned != rhs.positioned {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Message, rhs: Centrifugal_Centrifuge_Protocol_Message) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Connect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Connect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
    2: .same(proto: "version"),
    3: .same(proto: "data"),
    4: .same(proto: "subs"),
    5: .same(proto: "expires"),
    6: .same(proto: "ttl"),
    7: .same(proto: "ping"),
    8: .same(proto: "pong"),
    9: .same(proto: "session"),
    10: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.client) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Centrifugal_Centrifuge_Protocol_SubscribeResult>.self, value: &self.subs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.expires) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.ttl) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.ping) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.pong) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.client.isEmpty {
      try visitor.visitSingularStringField(value: self.client, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if !self.subs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Centrifugal_Centrifuge_Protocol_SubscribeResult>.self, value: self.subs, fieldNumber: 4)
    }
    if self.expires != false {
      try visitor.visitSingularBoolField(value: self.expires, fieldNumber: 5)
    }
    if self.ttl != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttl, fieldNumber: 6)
    }
    if self.ping != 0 {
      try visitor.visitSingularUInt32Field(value: self.ping, fieldNumber: 7)
    }
    if self.pong != false {
      try visitor.visitSingularBoolField(value: self.pong, fieldNumber: 8)
    }
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 9)
    }
    if !self.node.isEmpty {
      try visitor.visitSingularStringField(value: self.node, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Connect, rhs: Centrifugal_Centrifuge_Protocol_Connect) -> Bool {
    if lhs.client != rhs.client {return false}
    if lhs.version != rhs.version {return false}
    if lhs.data != rhs.data {return false}
    if lhs.subs != rhs.subs {return false}
    if lhs.expires != rhs.expires {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.ping != rhs.ping {return false}
    if lhs.pong != rhs.pong {return false}
    if lhs.session != rhs.session {return false}
    if lhs.node != rhs.node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Disconnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Disconnect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "reason"),
    3: .same(proto: "reconnect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.reconnect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if self.reconnect != false {
      try visitor.visitSingularBoolField(value: self.reconnect, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Disconnect, rhs: Centrifugal_Centrifuge_Protocol_Disconnect) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.reconnect != rhs.reconnect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_Refresh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Refresh"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expires"),
    2: .same(proto: "ttl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.expires) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.ttl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expires != false {
      try visitor.visitSingularBoolField(value: self.expires, fieldNumber: 1)
    }
    if self.ttl != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttl, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_Refresh, rhs: Centrifugal_Centrifuge_Protocol_Refresh) -> Bool {
    if lhs.expires != rhs.expires {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "data"),
    3: .same(proto: "subs"),
    4: .same(proto: "name"),
    5: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Centrifugal_Centrifuge_Protocol_SubscribeRequest>.self, value: &self.subs) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.subs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Centrifugal_Centrifuge_Protocol_SubscribeRequest>.self, value: self.subs, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_ConnectRequest, rhs: Centrifugal_Centrifuge_Protocol_ConnectRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.data != rhs.data {return false}
    if lhs.subs != rhs.subs {return false}
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_ConnectResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
    2: .same(proto: "version"),
    3: .same(proto: "expires"),
    4: .same(proto: "ttl"),
    5: .same(proto: "data"),
    6: .same(proto: "subs"),
    7: .same(proto: "ping"),
    8: .same(proto: "pong"),
    9: .same(proto: "session"),
    10: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.client) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.expires) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.ttl) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Centrifugal_Centrifuge_Protocol_SubscribeResult>.self, value: &self.subs) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.ping) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.pong) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.client.isEmpty {
      try visitor.visitSingularStringField(value: self.client, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.expires != false {
      try visitor.visitSingularBoolField(value: self.expires, fieldNumber: 3)
    }
    if self.ttl != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttl, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    if !self.subs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Centrifugal_Centrifuge_Protocol_SubscribeResult>.self, value: self.subs, fieldNumber: 6)
    }
    if self.ping != 0 {
      try visitor.visitSingularUInt32Field(value: self.ping, fieldNumber: 7)
    }
    if self.pong != false {
      try visitor.visitSingularBoolField(value: self.pong, fieldNumber: 8)
    }
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 9)
    }
    if !self.node.isEmpty {
      try visitor.visitSingularStringField(value: self.node, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_ConnectResult, rhs: Centrifugal_Centrifuge_Protocol_ConnectResult) -> Bool {
    if lhs.client != rhs.client {return false}
    if lhs.version != rhs.version {return false}
    if lhs.expires != rhs.expires {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.data != rhs.data {return false}
    if lhs.subs != rhs.subs {return false}
    if lhs.ping != rhs.ping {return false}
    if lhs.pong != rhs.pong {return false}
    if lhs.session != rhs.session {return false}
    if lhs.node != rhs.node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_RefreshRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_RefreshRequest, rhs: Centrifugal_Centrifuge_Protocol_RefreshRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_RefreshResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "client"),
    2: .same(proto: "version"),
    3: .same(proto: "expires"),
    4: .same(proto: "ttl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.client) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.expires) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.ttl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.client.isEmpty {
      try visitor.visitSingularStringField(value: self.client, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.expires != false {
      try visitor.visitSingularBoolField(value: self.expires, fieldNumber: 3)
    }
    if self.ttl != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttl, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_RefreshResult, rhs: Centrifugal_Centrifuge_Protocol_RefreshResult) -> Bool {
    if lhs.client != rhs.client {return false}
    if lhs.version != rhs.version {return false}
    if lhs.expires != rhs.expires {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_SubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "token"),
    3: .same(proto: "recover"),
    6: .same(proto: "epoch"),
    7: .same(proto: "offset"),
    8: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.recover) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.epoch) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.offset) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if self.recover != false {
      try visitor.visitSingularBoolField(value: self.recover, fieldNumber: 3)
    }
    if !self.epoch.isEmpty {
      try visitor.visitSingularStringField(value: self.epoch, fieldNumber: 6)
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt64Field(value: self.offset, fieldNumber: 7)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_SubscribeRequest, rhs: Centrifugal_Centrifuge_Protocol_SubscribeRequest) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.token != rhs.token {return false}
    if lhs.recover != rhs.recover {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_SubscribeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expires"),
    2: .same(proto: "ttl"),
    3: .same(proto: "recoverable"),
    6: .same(proto: "epoch"),
    7: .same(proto: "publications"),
    8: .same(proto: "recovered"),
    9: .same(proto: "offset"),
    10: .same(proto: "positioned"),
    11: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.expires) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.ttl) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.recoverable) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.epoch) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.publications) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.recovered) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.offset) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.positioned) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expires != false {
      try visitor.visitSingularBoolField(value: self.expires, fieldNumber: 1)
    }
    if self.ttl != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttl, fieldNumber: 2)
    }
    if self.recoverable != false {
      try visitor.visitSingularBoolField(value: self.recoverable, fieldNumber: 3)
    }
    if !self.epoch.isEmpty {
      try visitor.visitSingularStringField(value: self.epoch, fieldNumber: 6)
    }
    if !self.publications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publications, fieldNumber: 7)
    }
    if self.recovered != false {
      try visitor.visitSingularBoolField(value: self.recovered, fieldNumber: 8)
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt64Field(value: self.offset, fieldNumber: 9)
    }
    if self.positioned != false {
      try visitor.visitSingularBoolField(value: self.positioned, fieldNumber: 10)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_SubscribeResult, rhs: Centrifugal_Centrifuge_Protocol_SubscribeResult) -> Bool {
    if lhs.expires != rhs.expires {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.recoverable != rhs.recoverable {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.publications != rhs.publications {return false}
    if lhs.recovered != rhs.recovered {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.positioned != rhs.positioned {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_SubRefreshRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubRefreshRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_SubRefreshRequest, rhs: Centrifugal_Centrifuge_Protocol_SubRefreshRequest) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_SubRefreshResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubRefreshResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expires"),
    2: .same(proto: "ttl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.expires) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.ttl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expires != false {
      try visitor.visitSingularBoolField(value: self.expires, fieldNumber: 1)
    }
    if self.ttl != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttl, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_SubRefreshResult, rhs: Centrifugal_Centrifuge_Protocol_SubRefreshResult) -> Bool {
    if lhs.expires != rhs.expires {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_UnsubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsubscribeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_UnsubscribeRequest, rhs: Centrifugal_Centrifuge_Protocol_UnsubscribeRequest) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_UnsubscribeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsubscribeResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_UnsubscribeResult, rhs: Centrifugal_Centrifuge_Protocol_UnsubscribeResult) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_PublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_PublishRequest, rhs: Centrifugal_Centrifuge_Protocol_PublishRequest) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_PublishResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_PublishResult, rhs: Centrifugal_Centrifuge_Protocol_PublishResult) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_PresenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PresenceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_PresenceRequest, rhs: Centrifugal_Centrifuge_Protocol_PresenceRequest) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_PresenceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PresenceResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Centrifugal_Centrifuge_Protocol_ClientInfo>.self, value: &self.presence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.presence.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Centrifugal_Centrifuge_Protocol_ClientInfo>.self, value: self.presence, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_PresenceResult, rhs: Centrifugal_Centrifuge_Protocol_PresenceResult) -> Bool {
    if lhs.presence != rhs.presence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_PresenceStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PresenceStatsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_PresenceStatsRequest, rhs: Centrifugal_Centrifuge_Protocol_PresenceStatsRequest) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_PresenceStatsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PresenceStatsResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_clients"),
    2: .standard(proto: "num_users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numClients) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numUsers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numClients != 0 {
      try visitor.visitSingularUInt32Field(value: self.numClients, fieldNumber: 1)
    }
    if self.numUsers != 0 {
      try visitor.visitSingularUInt32Field(value: self.numUsers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_PresenceStatsResult, rhs: Centrifugal_Centrifuge_Protocol_PresenceStatsResult) -> Bool {
    if lhs.numClients != rhs.numClients {return false}
    if lhs.numUsers != rhs.numUsers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_StreamPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
    2: .same(proto: "epoch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.offset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.epoch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularUInt64Field(value: self.offset, fieldNumber: 1)
    }
    if !self.epoch.isEmpty {
      try visitor.visitSingularStringField(value: self.epoch, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_StreamPosition, rhs: Centrifugal_Centrifuge_Protocol_StreamPosition) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_HistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    7: .same(proto: "limit"),
    8: .same(proto: "since"),
    9: .same(proto: "reverse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._since) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.reverse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 7)
    }
    try { if let v = self._since {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.reverse != false {
      try visitor.visitSingularBoolField(value: self.reverse, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_HistoryRequest, rhs: Centrifugal_Centrifuge_Protocol_HistoryRequest) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs._since != rhs._since {return false}
    if lhs.reverse != rhs.reverse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_HistoryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HistoryResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publications"),
    2: .same(proto: "epoch"),
    3: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.publications) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.epoch) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publications, fieldNumber: 1)
    }
    if !self.epoch.isEmpty {
      try visitor.visitSingularStringField(value: self.epoch, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt64Field(value: self.offset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_HistoryResult, rhs: Centrifugal_Centrifuge_Protocol_HistoryResult) -> Bool {
    if lhs.publications != rhs.publications {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_PingRequest, rhs: Centrifugal_Centrifuge_Protocol_PingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_PingResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_PingResult, rhs: Centrifugal_Centrifuge_Protocol_PingResult) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_RPCRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RPCRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "method"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.method) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_RPCRequest, rhs: Centrifugal_Centrifuge_Protocol_RPCRequest) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_RPCResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RPCResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_RPCResult, rhs: Centrifugal_Centrifuge_Protocol_RPCResult) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Centrifugal_Centrifuge_Protocol_SendRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Centrifugal_Centrifuge_Protocol_SendRequest, rhs: Centrifugal_Centrifuge_Protocol_SendRequest) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
